## 目录
---
- [正则模式](#正则模式)
  - [特殊符号](#特殊符号)
- [创建正则](#创建正则)
- [使用正则](#使用正则)
  - [ exec](#-exec)
  - [lastIndex](#lastIndex)
- [字符串使用正则](#字符串使用正则)
  - [replace ](#replace-)
  - [search ](#search-)
  - [split](#split)
- [其他用法](#其他用法)
    - [零宽度正预测先行断言 (?=exp)](#零宽度正预测先行断言-?=exp)
    - [零宽度负预测先行断言 (?!exp)](#零宽度负预测先行断言-?!exp)
    - [零宽度正回顾后发断言 (?<=exp)](#零宽度正回顾后发断言-?<=exp)
    - [零宽度负回顾后发断言 (?<!exp)](#零宽度负回顾后发断言-?<!exp)
  - [括号的用法](#括号的用法)
    - [分组](#分组)
  - [贪婪匹配与惰性匹配](#贪婪匹配与惰性匹配)
  - [全局搜索](#全局搜索)
- [常用匹配模式](#常用匹配模式)
- [参考文章](#参考文章)
---

## 正则模式

`//` 包含的是正则模式，后面的表示标志，主要有以下几个：

- g 是全局

- i 表示忽略大小写

- m 表示多行（到末尾还会继续匹配）

### 特殊符号

常用的特殊符号，正则表达式都差不多

`.`**除了换行**外的所有字符 = `[^\n]`

`*` 匹配0次或多次 = `{0,}`

`+` 匹配1次或多次 = `{1,}`

`?` 匹配0次或1次，非贪婪匹配 = `{0,1}`

`[xyz]`表示xyz其中的任意一个字符

`[x-z]`表示x到z其中的任意一个字符

`[^xyz] `不匹配这个集合中的任何一个字符 （注意在中括号里的`[^]`就不表示行首了）

`\d`表示数字（digital） = `[0-9]`

`\D`表示非数字= `[^\d]`

`\s`表示空白字符（space）=`[\t \n \r \f \v] `  

`\S`表示非空格 = `[^\s]`

`\w`表示字符[0-9a-zA-Z\_\]（特别注意有个`_`）(word)

`\W`表示非字符

`ab|cd`表示匹配'ab'或者'cd'

`^`表示行的开头。

`$`表示行的结束。

`\b`匹配单词边界（在做取词的时候很有用） 

`\B`匹配非单词边界

`()`表示分组，内容会保存下来（在RegExp.$1..\$9里)

`{n}`匹配n次

`{n,} `匹配n次以上 

`{n,m}`匹配n-m次

## 创建正则

可以直接用字面量`//`来创建，或者使用`new RegExp(字符串，flag)`的方式创建，当然还能用eval来执行。

注意：使用`new RegExp（）`创建正则，如果出现了`\`,必须使用双重转义`\\`

```js
var reg = /\[test\]/ig
var reg = new RegExp('\\[test\\]','ig');
var reg = eval('/[test]/ig');
```

## 使用正则

### test

返回boolean

###  exec

成功返回一个数组，包含所有匹配成功的串（0位），包括分组（1位开始）

### lastIndex

每次匹配，指针都会移动

## 字符串使用正则

### match

找到一个或多个正则表达式的匹配。 

### replace 

替换与正则表达式匹配的子串。
replace可以替换分组，如果直接接字符串可以用$1...$99代替，如果function，那么第一个参数是匹配字符串，从arguments[1]开始是分组值
$&  与 regexp 相匹配的子串。
$`	位于匹配子串左侧的文本。
$'	位于匹配子串右侧的文本。
$$	直接量符号。
### search 

检索与正则表达式相匹配的值。

### split

把字符串分割为字符串数组。 

用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：

```js
'a b   c'.split(' '); // ['a', 'b', '', '', 'c']
//嗯，无法识别连续的空格，用正则表达式试试：
'a b   c'.split(/\s+/); // ['a', 'b', 'c']
//无论多少个空格都可以正常分割。加入,试试：
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
```

## 其他用法

### 断言

#### 零宽度正预测先行断言 (?=exp)

用来捕获出现在特定字符之前的字符，**只有当字符后面跟着某个特定字符才去捕获它**。

也就是说，它并不负责匹配，它只是种位置的查找，该位置必须要满特定条件（断言），而exp就条件。

```js
//正向前瞻  
var text = 'abcd223'
var re = /([a-z]+(?=\d))/i;  
//我们要匹配后面跟一个数字的单词，然后将单词返回，而不要返回数字  
//使用前瞻的好处是,前瞻的内容(?=\d)并不会当成一次匹配，下次匹配仍从它开始 
//注意，这里断言是判断位置，如果你写了一下这样的正则就会出问题
text = 'abc'
re = /a(?=b)c/
//好像看似是匹配的，其实这个正则不会匹配任何的字符串，因为它实际是匹配/ac/，但是它又要求a后面必须是有一个b的a。自相矛盾
// a(?=b)就会匹配abc
所以 reg = /a(?=b)bc/才会正确匹配，但是也没必要这样写了。
```

#### 零宽度负预测先行断言 (?!exp)

它用匹配只有**当字符后面不跟着某个特定字符时才去匹配它**。

```js
re = /([a-z](?!\d))/;i  
//将匹配后面不包含数字的字母,并且不会返回(?!\d)中的内容 
```

#### 零宽度正回顾后发断言 (?<=exp)

(?<=exp) 这个就是说字符出现的位置的前边是exp这个表达式。

```js
var str = '￥998$888';
var reg = /(?<=\$)\d+/;
console.log(reg.exec(str)) //888
```

#### 零宽度负回顾后发断言 (?<!exp)

(?<!exp) 这个就是说字符出现的位置的前边不能是exp这个表达式。

```js
var str = '￥998$888';
var reg = /(?<!\$)\d+/;
console.log(reg.exec(str)) //998`
```

### 括号的用法

括号的用法有三个：

1. 分组（抽取字符串），这是最（）的本职工作

   `/[a-z]+(\d+)/`

   从字符串中抽取后面的数字，保存在$1里

2. 当作子模式，后面可以用量词符（* + ? {} )约束 

   ` /java(script) ?/ `   匹配java或者javacript

3. 引用之前的模式用`\1,\2...`代表之前出现的第一个括号，第二个括号的子模式，它仅是代替了重复的模式，**它更是提供了一种约束，要求这引用部分完全一样**

   `/['"][^'"]*['"]/`  匹配引号和引号之间的内容（不限定开头和结尾引号一致，`"dfsdf'`也行）

   `/(['"])[^'"]*\1/` 就不一样了，要求前后的引号完全一致（`"abc'`就不行）

#### 分组

除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：

`^(\d{3})-(\d{3,8})$`分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：

注意：还有非捕获性分组`(?:)`，捕获的信息不会存储

```js
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

如果正则表达式中定义了组，就可以在RegExp对象上用`exec()`方法提取出子串来。

exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。

exec()方法在匹配失败时返回null。

提取子串非常有用。来看一个更凶残的例子：

```js
var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30'); // ['19:05:30', '19', '05', '30']
```

这个正则表达式可以直接识别合法的时间。但是有些时候，用正则表达式也无法做到完全验证，比如识别日期：

```js
var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
```

对于'2-30'，'4-31'这样的非法日期，用正则还是识别不了，或者说写出来非常困难，这时就需要程序配合识别了。

### 贪婪匹配与惰性匹配

需要特别指出的是，正则匹**配默认是贪婪匹配**，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：

```js
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
```

由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。

必须让`\d+`采用惰性匹配（非贪婪匹配，也就是尽可能少匹配），才能把后面的0匹配出来，加个`?`就可以让\d+采用非贪婪匹配：

```js
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
```

### 全局搜索

JavaScript的正则表达式还有几个特殊的标志，最常用的是`g`，表示全局匹配：

```js
var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。当我们指定g标志后，每次运行exec()，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```js
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;
// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10
re.exec(s); // ['VBScript']
re.lastIndex; // 20
re.exec(s); // ['JScript']
re.lastIndex; // 29
re.exec(s); // ['ECMAScript']
re.lastIndex; // 44
re.exec(s); // null，直到结束仍没有匹配到
```

全局匹配类似搜索，因此不能使用/^...$/，那样只会最多匹配一次。

正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。

## 常用匹配模式

- 匹配任意字符包括换行

`/[\s\S]*/`

- 匹配一个单词

`/\b\w+\b/`

- **校验密码强度**

密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。

`^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`

- **校验中文**

字符串仅能是中文。

`^[\\u4e00-\\u9fa5]{0,}$`

- **由数字、26个英文字母或下划线组成的字符串**

`^\\w+$`

- **校验E-Mail 地址**

用户名只能包含字母数字以及下划线，最少一位，最多25位，用户名后面紧跟@，后面是域名，域名名称要求只能包含字母数字和减号（-），并且不能以减号开头或结尾，然后后面是域名后缀（可以有多个），域名后缀必须是点号连上2-4位英文字母 

`var re = /^\w{1,15}(?:@(?!-))(?:(?:[a-z0-9-]*)(?:[a-z0-9](?!-))(?:\.(?!-)))+[a-z]{2,4}$'`

- **校验身份证号码**

下面是身份证号码的正则校验。15 或 18位。

15位：

`^[1-9]\\d{7}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}$`

18位：

`^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$`

- **校验日期**

“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年。

`^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$`

- **校验金额**

金额校验，精确到2位小数。

`^[0-9]+(.[0-9]{2})?$`

- **校验手机号**

下面是国内 13、15、18开头的手机号正则表达式。（可根据目前国内收集号扩展前两位开头号码）

`^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$`

- **判断IE的版本**

IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式。

`^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$`

- **校验IP-v4地址**

IP4 正则语句。

`\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b`

- **检查URL的前缀**

应用开发中很多时候需要区分请求是HTTPS还是HTTP，通过下面的表达式可以取出一个url的前缀然后再逻辑判断。

`if (!s.match(/^[a-zA-Z]+:\\/\\//)) {    s = 'http://' + s;}`

- **提取URL链接**

下面的这个表达式可以筛选出一段文本中的URL。

`^(f|ht){1}(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&=]*)?`

- **文件路径及扩展名校验**

验证windows下文件路径和扩展名（下面的例子中为.txt文件）

`^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?"<>|]+\\.txt(l)?$`

- **提取Color Hex Codes**

有时需要抽取网页中的颜色代码，可以使用下面的表达式。

`^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$`

## 参考文章

[http://www.cnblogs.com/chenmeng0818/p/6370819.html](http://www.cnblogs.com/chenmeng0818/p/6370819.html)

[http://www.cnblogs.com/aaronjs/archive/2012/06/30/2570970.html](http://www.cnblogs.com/aaronjs/archive/2012/06/30/2570970.html)

